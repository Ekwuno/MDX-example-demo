{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["default","sift","require","_","prepareRegex","makeRe","getValueAt","toDottedFields","objectToDottedField","liftResolvedFields","ensureIndexByTypedChain","getNodesByTypedChain","addResolvedNodes","getNode","siftGetNode","prepareQueryArgs","filterFields","Object","keys","reduce","acc","key","value","isPlainObject","getFilters","filters","push","isEqId","siftArgs","length","id","handleFirst","nodes","index","isEmpty","findIndex","$and","handleMany","result","filter","getFlatPropertyChain","obj","undefined","chain","props","getOwnPropertyNames","next","prop","runFlatFilterWithoutSift","targetValue","nodeTypeNames","typedKeyValueIndexes","nodesByKeyValue","join","runFilterAndSort","args","queryArgs","sort","resolvedFields","firstOnly","applyFilters","sortNodes","exports","runSift","filterWithoutSift","slice","filterWithSift","chainWithNeedle","pop","lastPath","forEach","typeName","_runSiftOnNodes","runSiftOnNodes","siftFilter","node","$eq","internal","includes","type","dottedFields","dottedFieldKeys","sortFields","fields","map","field","some","startsWith","v","sortOrder","order","toLowerCase","orderBy"],"mappings":"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","sourcesContent":["// @flow\nconst { default: sift } = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst { makeRe } = require(`micromatch`)\nconst { getValueAt } = require(`../utils/get-value-at`)\nconst {\n  toDottedFields,\n  objectToDottedField,\n  liftResolvedFields,\n} = require(`../db/common/query`)\nconst {\n  ensureIndexByTypedChain,\n  getNodesByTypedChain,\n  addResolvedNodes,\n  getNode: siftGetNode,\n} = require(`./nodes`)\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nconst prepareQueryArgs = (filterFields = {}) =>\n  Object.keys(filterFields).reduce((acc, key) => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      acc[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(value)\n    } else {\n      switch (key) {\n        case `regex`:\n          acc[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          acc[`$regex`] = makeRe(value)\n          break\n        default:\n          acc[`$${key}`] = value\n      }\n    }\n    return acc\n  }, {})\n\nconst getFilters = filters =>\n  Object.keys(filters).reduce(\n    (acc, key) => acc.push({ [key]: filters[key] }) && acc,\n    []\n  )\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(siftArgs) {\n  // The `id` of each node is invariably unique. So if a query is doing id $eq(string) it can find only one node tops\n  return (\n    siftArgs.length > 0 &&\n    siftArgs[0].id &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  if (nodes.length === 0) {\n    return []\n  }\n\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : nodes.findIndex(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : nodes.filter(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  return result?.length ? result : null\n}\n\n/**\n * Given an object, assert that it has exactly one leaf property and that this\n * leaf is a number, string, or boolean. Additionally confirms that the path\n * does not contain the special cased `elemMatch` name.\n * Returns undefined if not a flat path, if it contains `elemMatch`, or if the\n * leaf value was not a bool, number, or string.\n * If array, it contains the property path followed by the leaf value.\n * Returns `undefined` if any condition is not met\n *\n * Example: `{a: {b: {c: \"x\"}}}` is flat with a chain of `['a', 'b', 'c', 'x']`\n * Example: `{a: {b: \"x\", c: \"y\"}}` is not flat because x and y are 2 leafs\n *\n * @param {Object} obj\n * @returns {Array<string | number | boolean>|undefined}\n */\nconst getFlatPropertyChain = obj => {\n  if (!obj) {\n    return undefined\n  }\n\n  let chain = []\n  let props = Object.getOwnPropertyNames(obj)\n  let next = obj\n  while (props.length === 1) {\n    const prop = props[0]\n    if (prop === `elemMatch`) {\n      // TODO: Support handling this special case without sift as well\n      return undefined\n    }\n    chain.push(prop)\n    next = next[prop]\n    if (\n      typeof next === `string` ||\n      typeof next === `number` ||\n      typeof next === `boolean`\n    ) {\n      chain.push(next)\n      return chain\n    }\n    if (!next) {\n      return undefined\n    }\n    props = Object.getOwnPropertyNames(next)\n  }\n\n  // This means at least one object in the chain had more than one property\n  return undefined\n}\n\n/**\n * Given the chain of a simple filter, return the set of nodes that pass the\n * filter. The chain should be a property chain leading to the property to\n * check, followed by the value to check against. Common example:\n *   `allThings(filter: { fields: { slug: { eq: $slug } } })`\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n * The empty result value is null if firstOnly is false, or else an empty array.\n *\n * @param {Array<string>} chain Note: `eq` is assumed to be the leaf prop here\n * @param {boolean | number | string} targetValue chain.chain.eq === targetValue\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | Map<string, Map<string | number | boolean, Node>>} typedKeyValueIndexes\n * @returns {Array<Node> | undefined}\n */\nconst runFlatFilterWithoutSift = (\n  chain,\n  targetValue,\n  nodeTypeNames,\n  typedKeyValueIndexes\n) => {\n  ensureIndexByTypedChain(chain, nodeTypeNames, typedKeyValueIndexes)\n\n  const nodesByKeyValue = getNodesByTypedChain(\n    chain,\n    targetValue,\n    nodeTypeNames,\n    typedKeyValueIndexes\n  )\n\n  // If we couldn't find the needle then maybe sift can, for example if the\n  // schema contained a proxy; `slug: String @proxy(from: \"slugInternal\")`\n  // There are also cases (and tests) where id exists with a different type\n  if (!nodesByKeyValue) {\n    return undefined\n  }\n\n  if (chain.join(`,`) === `id`) {\n    // The `id` key is not indexed in Sets (because why) so don't spread it\n    return [nodesByKeyValue]\n  }\n\n  // In all other cases this must be a non-empty Set because the indexing\n  // mechanism does not create a Set unless there's a Node for it\n  return [...nodesByKeyValue]\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {boolean | number | string} args.type gqlType. See build-node-types\n * @property {boolean} args.firstOnly true if you want to return only the first\n *   result found. This will return a collection of size 1. Not a single element\n * @property {{filter?: Object, sort?: Object} | undefined} args.queryArgs\n * @property {undefined | Map<string, Map<string | number | boolean, Node>>} args.typedKeyValueIndexes\n *   May be undefined. A cache of indexes where you can look up Nodes grouped\n *   by a key: `types.join(',')+'/'+filterPath.join('+')`, which yields a Map\n *   which holds a Set of Nodes for the value that the filter is trying to eq\n *   against. If the property is `id` then there is no Set, it's just the Node.\n *   This object lives in query/query-runner.js and is passed down runQuery\n * @returns Collection of results. Collection will be limited to 1\n *   if `firstOnly` is true\n */\nconst runFilterAndSort = (args: Object) => {\n  const {\n    queryArgs: { filter, sort } = { filter: {}, sort: {} },\n    resolvedFields = {},\n    firstOnly = false,\n    nodeTypeNames,\n    typedKeyValueIndexes,\n  } = args\n\n  let result = applyFilters(\n    filter,\n    firstOnly,\n    nodeTypeNames,\n    typedKeyValueIndexes,\n    resolvedFields\n  )\n\n  return sortNodes(result, sort, resolvedFields)\n}\n\nexports.runSift = runFilterAndSort\n\n/**\n * Applies filter. First through a simple approach, which is much faster than\n * running sift, but not as versatile and correct. If no nodes were found then\n * it falls back to filtering through sift.\n *\n * @param {Object | undefined} filter\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | Map<string, Map<string | number | boolean, Node>>} typedKeyValueIndexes\n * @param resolvedFields\n * @returns {Array<Node> | undefined} Collection of results. Collection will be\n *   limited to 1 if `firstOnly` is true\n */\nconst applyFilters = (\n  filter,\n  firstOnly,\n  nodeTypeNames,\n  typedKeyValueIndexes,\n  resolvedFields\n) => {\n  let result\n  if (typedKeyValueIndexes) {\n    result = filterWithoutSift(filter, nodeTypeNames, typedKeyValueIndexes)\n    if (result) {\n      if (firstOnly) {\n        return result.slice(0, 1)\n      }\n      return result\n    }\n  }\n\n  return filterWithSift(filter, firstOnly, nodeTypeNames, resolvedFields)\n}\n\n/**\n * Check if the filter is \"flat\" (single leaf) and an \"eq\". If so, uses custom\n * indexes based on filter and types and returns any result it finds.\n * If conditions are not met or no nodes are found, returns undefined.\n *\n * @param {Object | undefined} filter\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | Map<string, Map<string | number | boolean, Node>>} typedKeyValueIndexes\n * @returns {Array|undefined} Collection of results\n */\nconst filterWithoutSift = (filter, nodeTypeNames, typedKeyValueIndexes) => {\n  if (!filter) {\n    return undefined\n  }\n\n  // Filter can be any struct of {a: {b: {c: {eq: \"x\"}}}} and we want to confirm\n  // there is exactly one leaf in this structure and that this leaf is `eq`. The\n  // actual names are irrelevant, they are a chain of props on a Node.\n\n  let chainWithNeedle = getFlatPropertyChain(filter)\n  if (!chainWithNeedle) {\n    return undefined\n  }\n\n  // `chainWithNeedle` should now be like:\n  //   `filter = {this: {is: {the: {chain: {eq: needle}}}}}`\n  //  ->\n  //   `['this', 'is', 'the', 'chain', 'eq', needle]`\n  let targetValue = chainWithNeedle.pop()\n  let lastPath = chainWithNeedle.pop()\n\n  // This can also be `ne`, `in` or any other grapqhl comparison op\n  if (lastPath !== `eq`) {\n    return undefined\n  }\n\n  return runFlatFilterWithoutSift(\n    chainWithNeedle,\n    targetValue,\n    nodeTypeNames,\n    typedKeyValueIndexes\n  )\n}\n\n/**\n * Use sift to apply filters\n *\n * @param {Object | undefined} filter\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param resolvedFields\n * @returns {Array<Node> | undefined | null} Collection of results. Collection\n *   will be limited to 1 if `firstOnly` is true\n */\nconst filterWithSift = (filter, firstOnly, nodeTypeNames, resolvedFields) => {\n  let nodes = []\n\n  nodeTypeNames.forEach(typeName => addResolvedNodes(typeName, nodes))\n\n  return _runSiftOnNodes(\n    nodes,\n    filter,\n    firstOnly,\n    nodeTypeNames,\n    resolvedFields,\n    siftGetNode\n  )\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n * Note: this entry point is used by GATSBY_DB_NODES=loki\n *\n * @param {Array<Node>} nodes Should be all nodes of given type(s)\n * @param args Legacy api arg, see _runSiftOnNodes\n * @param {?function(id: string): Node} getNode\n * @returns {Array<Node> | undefined | null} Collection of results. Collection\n *   will be limited to 1 if `firstOnly` is true\n */\nconst runSiftOnNodes = (nodes, args, getNode = siftGetNode) => {\n  const {\n    queryArgs: { filter } = { filter: {} },\n    firstOnly = false,\n    resolvedFields = {},\n    nodeTypeNames,\n  } = args\n\n  return _runSiftOnNodes(\n    nodes,\n    filter,\n    firstOnly,\n    nodeTypeNames,\n    resolvedFields,\n    getNode\n  )\n}\n\nexports.runSiftOnNodes = runSiftOnNodes\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n *\n * @param {Array<Node>} nodes Should be all nodes of given type(s)\n * @param {Object | undefined} filter\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param resolvedFields\n * @param {function(id: string): Node} getNode Note: this is different for loki\n * @returns {Array<Node> | undefined | null} Collection of results. Collection\n *   will be limited to 1 if `firstOnly` is true\n */\nconst _runSiftOnNodes = (\n  nodes,\n  filter,\n  firstOnly,\n  nodeTypeNames,\n  resolvedFields,\n  getNode\n) => {\n  let siftFilter = getFilters(\n    liftResolvedFields(toDottedFields(prepareQueryArgs(filter)), resolvedFields)\n  )\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(siftFilter)) {\n    const node = getNode(siftFilter[0].id.$eq)\n\n    if (\n      !node ||\n      (node.internal && !nodeTypeNames.includes(node.internal.type))\n    ) {\n      if (firstOnly) {\n        return []\n      }\n      return null\n    }\n\n    return [node]\n  }\n\n  if (firstOnly) {\n    return handleFirst(siftFilter, nodes)\n  } else {\n    return handleMany(siftFilter, nodes)\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n *\n * @param {Array<Node> | undefined | null} nodes Pre-filtered list of nodes\n * @param {Object | undefined} sort Sorting arguments\n * @param resolvedFields\n * @returns {Array<Node> | undefined | null} Same as input, except sorted\n */\nconst sortNodes = (nodes, sort, resolvedFields) => {\n  if (!sort || nodes?.length <= 1) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const sortFields = sort.fields\n    .map(field => {\n      if (\n        dottedFields[field] ||\n        dottedFieldKeys.some(key => field.startsWith(key))\n      ) {\n        return `__gatsby_resolved.${field}`\n      } else {\n        return field\n      }\n    })\n    .map(field => v => getValueAt(v, field))\n  const sortOrder = sort.order.map(order => order.toLowerCase())\n\n  return _.orderBy(nodes, sortFields, sortOrder)\n}\n"],"file":"run-sift.js"}